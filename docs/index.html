<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Johan Hidding" />
  <title>2D particle-mesh n-body code</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- Bootstrap 4.5.0 stylesheet -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
  <link rel="stylesheet" href="css/mods.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
<!-- <script data-main="scripts/main" src="js/require.js"></script> -->
  <!-- Load React. -->
  <!-- Note: when deploying, replace "development.js" with "production.min.js". -->
<!--  <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script> -->


</head>
<body class="d-flex flex-column">

<nav id="TOC" class="navbar navbar-dark bg-dark">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a href="#" class="ml-5 mr-auto navbar-brand">2D particle-mesh n-body code<br><span style="font-size: smaller"> 
        by <i>Johan Hidding</i></span></a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul>
<li><a href="#instructions">Instructions</a></li>
<li><a href="#the-math">The math</a></li>
<li><a href="#the-simulation">The simulation</a></li>
<li><a href="#plotting-the-phase-space-submanifold">Plotting the phase-space submanifold</a></li>
<li><a href="#introducing-constrained-fields">Introducing Constrained Fields</a></li>
<li><a href="#bibliography">References</a></li>
</ul>
</div>
</nav>

<!-- <nav class="navbar navbar-dark navbar-expand-md bg-dark mb-4">
<p class="author">Johan Hidding</p>
</nav>
 -->

<main role="main" class="flex-fill"><div class="container my-5">
<p><a href="https://entangled.github.io/"><img src="https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff" alt="Entangled badge" /></a> <a href="https://doi.org/10.5281/zenodo.4158731"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.4158731.svg" alt="DOI" /></a></p>
<p>This is a particle-mesh n-body code for cosmological n-body simulations. This code has several uses.</p>
<ul>
<li>Testing new methods: For many methods of analysis in cosmology it can be very helpful to have a 2D sample available to test them with.</li>
<li>Teaching: This code is very nice to play around with for students, since it is written in 100% Python.</li>
<li>Learning: Lastly, having 2D simulations can give a great deal of insight.</li>
</ul>
<figure>
<img src="figures/x.collage.png" alt="A sample simulation, three time steps; the bottom row is a zoom-in." /><figcaption aria-hidden="true">A sample simulation, three time steps; the bottom row is a zoom-in.</figcaption>
</figure>
<h1 id="instructions">Instructions</h1>
<p>To run the code, you need to have installed:</p>
<ul>
<li>Python 3.8</li>
<li>Numpy</li>
<li>Scipy</li>
<li>Gnuplot</li>
</ul>
<p>Run with:</p>
<pre><code>python -m nbody.nbody</code></pre>
<h2 id="license">License</h2>
<p>Copyright 2015-2020 Johan Hidding; This code is licensed under the Apache license version 2.0, see <a href="https://www.apache.org/licenses/LICENSE-2.0">LICENSE</a>.</p>
<h2 id="citation">Citation</h2>
<p>If you use this code in scientific publication, please cite it using <a href="https://doi.org/10.5281/zenodo.4158731">DOI:10.5281/zenodo.4158731</a>.</p>
<h1 id="the-math">The math</h1>
<p>It would be a bit much to derive all equations here from first principles. If you need a good introductory text, I recommend Barbara yden’s book “Introduction to Cosmology” <span class="citation" data-cites="Ryden2017">(<a href="#ref-Ryden2017" role="doc-biblioref">Ryden 2017</a>)</span> (<a href="http://carina.fcaglp.unlp.edu.ar/extragalactica/Bibliografia/Ryden_IntroCosmo.pdf">link to PDF</a>) The equations that gouvern the distribution of matter in the Universe are given by Newtons law for gravity. We assume gravity is the sole force responsible for forming strunctures in the Universe and that relativistic effects play a minor role. Moreover we will assume that this process is dominated by <em>dark matter</em>. The Newtonian field equation for gravity is the Poisson equation</p>
<p><span id="eq:poisson-proper" class="eqnos"><span class="math display">\[\nabla^2 \Phi = 4 \pi G \rho.\]</span><span class="eqnos-number">(1)</span></span></p>
<p>However, in an expanding Universe this equation changes slightly to</p>
<p><span id="eq:poisson-comoving" class="eqnos"><span class="math display">\[\frac{1}{a^2} \nabla^2 \phi = 4 \pi G \rho_u \delta.\]</span><span class="eqnos-number">(2)</span></span></p>
<p>Here <span class="math inline">\(a\)</span> is the Hubble expansion factor, <span class="math inline">\(\delta\)</span> the density perturbation</p>
<p><span id="eq:density-contrast" class="eqnos"><span class="math display">\[\delta + 1 = \frac{\rho}{\rho_u},\]</span><span class="eqnos-number">(3)</span></span></p>
<p>and <span class="math inline">\(\phi\)</span> is the potential perturbation. Similarly the Euler equation describing Newton’s second law can be written in Lagrangian form as</p>
<p><span id="eq:euler" class="eqnos"><span class="math display">\[\partial_t(a \vec{v}) \big|_{q={\rm cst}} = -\nabla \phi.\]</span><span class="eqnos-number">(4)</span></span></p>
<p>Defining <span class="math inline">\(v\)</span> as the comoving velocity <span class="math inline">\(v := a\dot{x}\)</span>. We have two sets of coordinates <span class="math inline">\(q\)</span> and <span class="math inline">\(x\)</span>. <span class="math inline">\(q\)</span> being a label on a particle, telling it where it started at time <span class="math inline">\(t = 0\)</span>. Then</p>
<p><span id="eq:particle-trajectory" class="eqnos"><span class="math display">\[x = q + \int \frac{v}{a} {\rm d t}.\]</span><span class="eqnos-number">(5)</span></span></p>
<p>We define a momentum <span class="math inline">\(p := a^2 \dot{x} = a v\)</span>, and rewrite the factor of proportionality</p>
<p><span id="eq:poisson-rewrite" class="eqnos"><span class="math display">\[4 \pi G \rho_u = \frac{3H_0^2 \Omega_0}{2a^3},\]</span><span class="eqnos-number">(6)</span></span></p>
<p>so that the Poisson equation becomes</p>
<p><span id="eq:poisson-unitfree" class="eqnos"><span class="math display">\[a\nabla^2 \phi = \frac{3}{2} \Omega_m H_0^2 \delta,\]</span><span class="eqnos-number">(7)</span></span></p>
<p>and the Euler equation</p>
<p><span id="eq:euler-comoving" class="eqnos"><span class="math display">\[\dot{p} = - \nabla \phi.\]</span><span class="eqnos-number">(8)</span></span></p>
<p>To this we add the Friedman equation that describes the evolution of the expansion factor</p>
<p><span id="eq:friedman-1" class="eqnos"><span class="math display">\[\dot{a} = H_0 a \sqrt{\Omega_{\Lambda} + \Omega_{m} a^{-3} + (1 - \Omega) a^{-2}}.\]</span><span class="eqnos-number">(9)</span></span></p>
<p>Note that all time dependence in these equations is in the expansion factor <span class="math inline">\(a(t)\)</span>, so we may express all time derivatives in terms of <span class="math inline">\(a\)</span>.</p>
<p><span id="eq:position-a" class="eqnos"><span class="math display">\[\dot{x} = \frac{p}{a^2}\quad \to \quad \partial_a x = \frac{p}{a^2 \dot{a}}\]</span><span class="eqnos-number">(10)</span></span> <span id="eq:momentum-a" class="eqnos"><span class="math display">\[\dot{p} = -\nabla \phi \quad \to \quad \partial_a p = - \frac{\nabla \phi}{\dot{a}}\]</span><span class="eqnos-number">(11)</span></span></p>
<p>This means we do not need to solve the Friedman equation explicitly. Rather we use <span class="math inline">\(a\)</span> as integration variable and use the Friedman equation to determine the relevant derivative <span class="math inline">\(\dot{a}\)</span>.</p>
<h1 id="the-simulation">The simulation</h1>
<p>The code is structured in the following components:</p>
<ul>
<li>Cosmology: we need to know Hubble factor <span class="math inline">\(H\)</span> as a function of the expansion factor <span class="math inline">\(a\)</span>.</li>
<li>Mass deposition: PM codes need a way to convert from particles to a grid representation of the density.</li>
<li>Interpolation: Then we need to go back and interpolate grid quantities on particle coordinates.</li>
<li>Integrator: Cosmic structure formation is described by a Hamiltonian system of equations: we need to solve these, in this case using the Leap-frog method.</li>
<li>Solver: To solve the Poisson equation, we need to integrate the density in Fourier space to obtain the potential.</li>
<li>Initialization: The simulation is started using the Zeldovich Approximation.</li>
<li>Main: glue everything together.</li>
</ul>
<div class="annotated-code">
<p><span><em>«nbody/nbody.py»=</em></span></p>
<div class="sourceCode" id="cb2" data-file="nbody/nbody.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>imports<span class="op">&gt;&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>cosmology<span class="op">&gt;&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>mass<span class="op">-</span>deposition<span class="op">&gt;&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>mass<span class="op">-</span>deposition<span class="op">-</span>numba<span class="op">&gt;&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>interpolation<span class="op">&gt;&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>integrator<span class="op">&gt;&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solver<span class="op">&gt;&gt;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>initialization<span class="op">&gt;&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>main<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>Some things we will definitely need:</p>
<div class="annotated-code">
<p><span><em>«imports»=</em></span></p>
<div class="sourceCode" id="imports"><pre class="sourceCode python"><code class="sourceCode python"><span id="imports-1"><a href="#imports-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> __future__ <span class="im">import</span> annotations</span>
<span id="imports-2"><a href="#imports-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="imports-3"><a href="#imports-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="imports-4"><a href="#imports-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> quad</span>
<span id="imports-5"><a href="#imports-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numba</span>
<span id="imports-6"><a href="#imports-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .cft <span class="im">import</span> Box</span>
<span id="imports-7"><a href="#imports-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> . <span class="im">import</span> gnuplot <span class="im">as</span> gp</span>
<span id="imports-8"><a href="#imports-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="imports-9"><a href="#imports-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> abc <span class="im">import</span> ABC, abstractmethod</span>
<span id="imports-10"><a href="#imports-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Generic, TypeVar, Callable, Tuple</span>
<span id="imports-11"><a href="#imports-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span></code></pre></div>
</div>
<h2 id="the-box">The Box</h2>
<p>The <code>Box</code> class contains all information about the simulation box: mainly the size in pixels and the physical size it represents. All operations will assume periodic boundary conditions. In <code>numpy</code> this is achieved by using <code>np.roll</code> to shift a grid along a given axis.</p>
<h2 id="cosmology">Cosmology</h2>
<p>The background cosmology is described by a function giving the scale function <span class="math inline">\(a(t)\)</span> as a function of time. In standard Big Bang cosmology this scale function is computed from three parameters (ignoring baryons): <span class="math inline">\(H_0\)</span> the Hubble expansion rate at <span class="math inline">\(t_0\)</span> (<span class="math inline">\(t_0\)</span> being now), <span class="math inline">\(\Omega_{m}\)</span> the matter density expressed as a fraction of the critical density, and <span class="math inline">\(\Omega_{\Lambda}\)</span> the dark energy (cosmological constant) component, again expressed as a fraction of the critical density.</p>
<div class="annotated-code">
<p><span><em>«cosmology»=</em></span></p>
<div class="sourceCode" id="cosmology"><pre class="sourceCode python"><code class="sourceCode python"><span id="cosmology-1"><a href="#cosmology-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cosmology-2"><a href="#cosmology-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Cosmology:</span>
<span id="cosmology-3"><a href="#cosmology-3" aria-hidden="true" tabindex="-1"></a>    H0 : <span class="bu">float</span></span>
<span id="cosmology-4"><a href="#cosmology-4" aria-hidden="true" tabindex="-1"></a>    OmegaM : <span class="bu">float</span></span>
<span id="cosmology-5"><a href="#cosmology-5" aria-hidden="true" tabindex="-1"></a>    OmegaL : <span class="bu">float</span></span>
<span id="cosmology-6"><a href="#cosmology-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cosmology-7"><a href="#cosmology-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>cosmology<span class="op">-</span>methods<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>From these parameters, we can compute the curvature,</p>
<p><span id="eq:curvature" class="eqnos"><span class="math display">\[\Omega_k = 1 - \Omega_{m} - \Omega_{\Lambda},\]</span><span class="eqnos-number">(12)</span></span></p>
<div class="annotated-code">
<p><span><em>«cosmology-methods»=</em></span></p>
<div class="sourceCode" id="cosmology-methods"><pre class="sourceCode python"><code class="sourceCode python"><span id="cosmology-methods-1"><a href="#cosmology-methods-1" aria-hidden="true" tabindex="-1"></a><span class="at">@property</span></span>
<span id="cosmology-methods-2"><a href="#cosmology-methods-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> OmegaK(<span class="va">self</span>):</span>
<span id="cosmology-methods-3"><a href="#cosmology-methods-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.OmegaM <span class="op">-</span> <span class="va">self</span>.OmegaL</span></code></pre></div>
</div>
<p>and the (a?) gravitational constant,</p>
<p><span id="eq:grav-const" class="eqnos"><span class="math display">\[G = \frac{3}{2} \Omega_{m} H_0^2.\]</span><span class="eqnos-number">(13)</span></span></p>
<div class="annotated-code">
<p><span><em>«cosmology-methods»+</em></span></p>
<div class="sourceCode" id="cosmology-methods"><pre class="sourceCode python"><code class="sourceCode python"><span id="cosmology-methods-1"><a href="#cosmology-methods-1" aria-hidden="true" tabindex="-1"></a><span class="at">@property</span></span>
<span id="cosmology-methods-2"><a href="#cosmology-methods-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> G(<span class="va">self</span>):</span>
<span id="cosmology-methods-3"><a href="#cosmology-methods-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">3.</span><span class="op">/</span><span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.OmegaM <span class="op">*</span> <span class="va">self</span>.H0<span class="op">**</span><span class="dv">2</span></span></code></pre></div>
</div>
<p>The background cosmology is embodied by the Friedman equation</p>
<p><span id="eq:friedman-2" class="eqnos"><span class="math display">\[\dot{a} = H_0 a \sqrt{\Omega_{\Lambda} + \Omega_{m} a^{-3} + (1 - \Omega) a^{-2}}.\]</span><span class="eqnos-number">(14)</span></span></p>
<div class="annotated-code">
<p><span><em>«cosmology-methods»+</em></span></p>
<div class="sourceCode" id="cosmology-methods"><pre class="sourceCode python"><code class="sourceCode python"><span id="cosmology-methods-1"><a href="#cosmology-methods-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> da(<span class="va">self</span>, a):</span>
<span id="cosmology-methods-2"><a href="#cosmology-methods-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span>.H0 <span class="op">*</span> a <span class="op">*</span> np.sqrt(</span>
<span id="cosmology-methods-3"><a href="#cosmology-methods-3" aria-hidden="true" tabindex="-1"></a>              <span class="va">self</span>.OmegaL <span class="op">\</span></span>
<span id="cosmology-methods-4"><a href="#cosmology-methods-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="va">self</span>.OmegaM <span class="op">*</span> a<span class="op">**-</span><span class="dv">3</span> <span class="op">\</span></span>
<span id="cosmology-methods-5"><a href="#cosmology-methods-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="va">self</span>.OmegaK <span class="op">*</span> a<span class="op">**-</span><span class="dv">2</span>)</span></code></pre></div>
</div>
<p>Later on we will need the <em>growing mode</em> solution for this universe.</p>
<p><span id="eq:growing-mode-t" class="eqnos"><span class="math display">\[D(t) = H(t) \int_0^t \frac{{\rm d} t&#39;}{a(t&#39;)^2 H(t&#39;)^2}\]</span><span class="eqnos-number">(15)</span></span></p>
<p>We’d like to do the integration in terms of <span class="math inline">\(a\)</span>, substituting <span class="math inline">\({\rm d}t = {\rm d}a/\dot{a}\)</span>.</p>
<p><span id="eq:growing-mode-a" class="eqnos"><span class="math display">\[D(a) = \frac{\dot{a}}{a} \int_0^a \frac{{\rm d}a}{\dot{a}^3}\]</span><span class="eqnos-number">(16)</span></span></p>
<p>For all cases that we’re interested in, we can integrate this equation directly to obtain the growing mode solution. We cannot start the integration from <span class="math inline">\(a=0\)</span>, but in the limit of <span class="math inline">\(a \to 0\)</span>, we have that <span class="math inline">\(D_{+} \approx a\)</span>.</p>
<div class="annotated-code">
<p><span><em>«cosmology-methods»+</em></span></p>
<div class="sourceCode" id="cosmology-methods"><pre class="sourceCode python"><code class="sourceCode python"><span id="cosmology-methods-1"><a href="#cosmology-methods-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> growing_mode(<span class="va">self</span>, a):</span>
<span id="cosmology-methods-2"><a href="#cosmology-methods-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(a, np.ndarray):</span>
<span id="cosmology-methods-3"><a href="#cosmology-methods-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array([<span class="va">self</span>.growing_mode(b) <span class="cf">for</span> b <span class="kw">in</span> a])</span>
<span id="cosmology-methods-4"><a href="#cosmology-methods-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> a <span class="op">&lt;=</span> <span class="fl">0.001</span>:</span>
<span id="cosmology-methods-5"><a href="#cosmology-methods-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a</span>
<span id="cosmology-methods-6"><a href="#cosmology-methods-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cosmology-methods-7"><a href="#cosmology-methods-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.factor <span class="op">*</span> <span class="va">self</span>.adot(a)<span class="op">/</span>a <span class="op">\</span></span>
<span id="cosmology-methods-8"><a href="#cosmology-methods-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> quad(<span class="kw">lambda</span> b: <span class="va">self</span>.adot(b)<span class="op">**</span>(<span class="op">-</span><span class="dv">3</span>), <span class="fl">0.00001</span>, a)[<span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.00001</span></span></code></pre></div>
</div>
<p>Using this, we can define two standard cosmologies, ΛCDM and Einstein-de Sitter.</p>
<div class="annotated-code">
<p><span><em>«cosmology»+</em></span></p>
<div class="sourceCode" id="cosmology"><pre class="sourceCode python"><code class="sourceCode python"><span id="cosmology-1"><a href="#cosmology-1" aria-hidden="true" tabindex="-1"></a>LCDM <span class="op">=</span> Cosmology(<span class="fl">68.0</span>, <span class="fl">0.31</span>, <span class="fl">0.69</span>)</span>
<span id="cosmology-2"><a href="#cosmology-2" aria-hidden="true" tabindex="-1"></a>EdS <span class="op">=</span> Cosmology(<span class="fl">70.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>)</span></code></pre></div>
</div>
<h2 id="mass-deposition">Mass deposition</h2>
<p>To do the mass deposition, that is, convert the position of particles into a 2D mesh of densities, we use the cloud-in-cell method. Every particle is smeared out over its four nearest neighbours, weighted by the distance to each neighbour. This principle is similar (but inverse) to a linear interpolation scheme: we compute the integer index of the grid-cell the particle belongs to, and use the floating-point remainder to compute the fractions in all the four neighbours. In this case however, we abuse the <code>histogram2d</code> function in <code>numpy</code> to do the interpolation for us.</p>
<div class="annotated-code">
<p><span><em>«mass-deposition»=</em></span></p>
<div class="sourceCode" id="mass-deposition"><pre class="sourceCode python"><code class="sourceCode python"><span id="mass-deposition-1"><a href="#mass-deposition-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> md_cic(B: Box, X: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="mass-deposition-2"><a href="#mass-deposition-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Takes a 2*M array of particle positions and returns an array of shape</span></span>
<span id="mass-deposition-3"><a href="#mass-deposition-3" aria-hidden="true" tabindex="-1"></a><span class="co">    `B.shape`. The result is a density field computed by cloud-in-cell method.&quot;&quot;&quot;</span></span>
<span id="mass-deposition-4"><a href="#mass-deposition-4" aria-hidden="true" tabindex="-1"></a>    f  <span class="op">=</span> X <span class="op">-</span> np.floor(X)</span>
<span id="mass-deposition-5"><a href="#mass-deposition-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="mass-deposition-6"><a href="#mass-deposition-6" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.zeros(B.shape, dtype<span class="op">=</span><span class="st">&#39;float64&#39;</span>)</span>
<span id="mass-deposition-7"><a href="#mass-deposition-7" aria-hidden="true" tabindex="-1"></a>    rho_, x_, y_ <span class="op">=</span> np.histogram2d(X[:,<span class="dv">0</span>]<span class="op">%</span>B.N, X[:,<span class="dv">1</span>]<span class="op">%</span>B.N, bins<span class="op">=</span>B.shape,</span>
<span id="mass-deposition-8"><a href="#mass-deposition-8" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">range</span><span class="op">=</span>[[<span class="dv">0</span>, B.N], [<span class="dv">0</span>, B.N]],</span>
<span id="mass-deposition-9"><a href="#mass-deposition-9" aria-hidden="true" tabindex="-1"></a>                        weights<span class="op">=</span>(<span class="dv">1</span> <span class="op">-</span> f[:,<span class="dv">0</span>])<span class="op">*</span>(<span class="dv">1</span> <span class="op">-</span> f[:,<span class="dv">1</span>]))</span>
<span id="mass-deposition-10"><a href="#mass-deposition-10" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">+=</span> rho_</span>
<span id="mass-deposition-11"><a href="#mass-deposition-11" aria-hidden="true" tabindex="-1"></a>    rho_, x_, y_ <span class="op">=</span> np.histogram2d((X[:,<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>B.N, X[:,<span class="dv">1</span>]<span class="op">%</span>B.N, bins<span class="op">=</span>B.shape,</span>
<span id="mass-deposition-12"><a href="#mass-deposition-12" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">range</span><span class="op">=</span>[[<span class="dv">0</span>, B.N], [<span class="dv">0</span>, B.N]],</span>
<span id="mass-deposition-13"><a href="#mass-deposition-13" aria-hidden="true" tabindex="-1"></a>                        weights<span class="op">=</span>(f[:,<span class="dv">0</span>])<span class="op">*</span>(<span class="dv">1</span> <span class="op">-</span> f[:,<span class="dv">1</span>]))</span>
<span id="mass-deposition-14"><a href="#mass-deposition-14" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">+=</span> rho_</span>
<span id="mass-deposition-15"><a href="#mass-deposition-15" aria-hidden="true" tabindex="-1"></a>    rho_, x_, y_ <span class="op">=</span> np.histogram2d(X[:,<span class="dv">0</span>]<span class="op">%</span>B.N, (X[:,<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>B.N, bins<span class="op">=</span>B.shape,</span>
<span id="mass-deposition-16"><a href="#mass-deposition-16" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">range</span><span class="op">=</span>[[<span class="dv">0</span>, B.N], [<span class="dv">0</span>, B.N]],</span>
<span id="mass-deposition-17"><a href="#mass-deposition-17" aria-hidden="true" tabindex="-1"></a>                        weights<span class="op">=</span>(<span class="dv">1</span> <span class="op">-</span> f[:,<span class="dv">0</span>])<span class="op">*</span>(f[:,<span class="dv">1</span>]))</span>
<span id="mass-deposition-18"><a href="#mass-deposition-18" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">+=</span> rho_</span>
<span id="mass-deposition-19"><a href="#mass-deposition-19" aria-hidden="true" tabindex="-1"></a>    rho_, x_, y_ <span class="op">=</span> np.histogram2d((X[:,<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>B.N, (X[:,<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>B.N, bins<span class="op">=</span>B.shape,</span>
<span id="mass-deposition-20"><a href="#mass-deposition-20" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">range</span><span class="op">=</span>[[<span class="dv">0</span>, B.N], [<span class="dv">0</span>, B.N]],</span>
<span id="mass-deposition-21"><a href="#mass-deposition-21" aria-hidden="true" tabindex="-1"></a>                        weights<span class="op">=</span>(f[:,<span class="dv">0</span>])<span class="op">*</span>(f[:,<span class="dv">1</span>]))</span>
<span id="mass-deposition-22"><a href="#mass-deposition-22" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">+=</span> rho_</span>
<span id="mass-deposition-23"><a href="#mass-deposition-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="mass-deposition-24"><a href="#mass-deposition-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rho</span></code></pre></div>
</div>
<h3 id="numba-implementation">Numba implementation</h3>
<p>It may be more efficient to do the mass deposition using Numba.</p>
<div class="annotated-code">
<p><span><em>«mass-deposition-numba»=</em></span></p>
<div class="sourceCode" id="mass-deposition-numba"><pre class="sourceCode python"><code class="sourceCode python"><span id="mass-deposition-numba-1"><a href="#mass-deposition-numba-1" aria-hidden="true" tabindex="-1"></a><span class="at">@numba.jit</span></span>
<span id="mass-deposition-numba-2"><a href="#mass-deposition-numba-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> md_cic_2d(shape: Tuple[<span class="bu">int</span>], pos: np.ndarray, tgt: np.ndarray):</span>
<span id="mass-deposition-numba-3"><a href="#mass-deposition-numba-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(pos)):</span>
<span id="mass-deposition-numba-4"><a href="#mass-deposition-numba-4" aria-hidden="true" tabindex="-1"></a>        idx0, idx1 <span class="op">=</span> <span class="bu">int</span>(np.floor(pos[i,<span class="dv">0</span>])), <span class="bu">int</span>(np.floor(pos[i,<span class="dv">1</span>]))</span>
<span id="mass-deposition-numba-5"><a href="#mass-deposition-numba-5" aria-hidden="true" tabindex="-1"></a>        f0, f1     <span class="op">=</span> pos[i,<span class="dv">0</span>] <span class="op">-</span> idx0, pos[i,<span class="dv">1</span>] <span class="op">-</span> idx1</span>
<span id="mass-deposition-numba-6"><a href="#mass-deposition-numba-6" aria-hidden="true" tabindex="-1"></a>        tgt[idx0 <span class="op">%</span> shape[<span class="dv">0</span>], idx1 <span class="op">%</span> shape[<span class="dv">1</span>]] <span class="op">+=</span> (<span class="dv">1</span> <span class="op">-</span> f0) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> f1)</span>
<span id="mass-deposition-numba-7"><a href="#mass-deposition-numba-7" aria-hidden="true" tabindex="-1"></a>        tgt[(idx0 <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> shape[<span class="dv">0</span>], idx1 <span class="op">%</span> shape[<span class="dv">1</span>]] <span class="op">+=</span> f0 <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> f1)</span>
<span id="mass-deposition-numba-8"><a href="#mass-deposition-numba-8" aria-hidden="true" tabindex="-1"></a>        tgt[idx0 <span class="op">%</span> shape[<span class="dv">0</span>], (idx1 <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> shape[<span class="dv">1</span>]] <span class="op">+=</span> (<span class="dv">1</span> <span class="op">-</span> f0) <span class="op">*</span> f1</span>
<span id="mass-deposition-numba-9"><a href="#mass-deposition-numba-9" aria-hidden="true" tabindex="-1"></a>        tgt[(idx0 <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> shape[<span class="dv">0</span>], (idx1 <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> shape[<span class="dv">1</span>]] <span class="op">+=</span> f0 <span class="op">*</span> f1</span></code></pre></div>
</div>
<h2 id="interpolation">Interpolation</h2>
<p>To read a value from a grid, given a particle position, we need to interpolate. This routine performs linear interpolation on the grid.</p>
<div class="annotated-code">
<p><span><em>«interpolation»=</em></span></p>
<div class="sourceCode" id="interpolation"><pre class="sourceCode python"><code class="sourceCode python"><span id="interpolation-1"><a href="#interpolation-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Interp2D:</span>
<span id="interpolation-2"><a href="#interpolation-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;Reasonably fast bilinear interpolation routine&quot;</span></span>
<span id="interpolation-3"><a href="#interpolation-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</span>
<span id="interpolation-4"><a href="#interpolation-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="interpolation-5"><a href="#interpolation-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.shape <span class="op">=</span> data.shape</span>
<span id="interpolation-6"><a href="#interpolation-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="interpolation-7"><a href="#interpolation-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="interpolation-8"><a href="#interpolation-8" aria-hidden="true" tabindex="-1"></a>        X1 <span class="op">=</span> np.floor(x).astype(<span class="bu">int</span>) <span class="op">%</span> <span class="va">self</span>.shape</span>
<span id="interpolation-9"><a href="#interpolation-9" aria-hidden="true" tabindex="-1"></a>        X2 <span class="op">=</span> np.ceil(x).astype(<span class="bu">int</span>) <span class="op">%</span> <span class="va">self</span>.shape</span>
<span id="interpolation-10"><a href="#interpolation-10" aria-hidden="true" tabindex="-1"></a>        xm <span class="op">=</span> x <span class="op">%</span> <span class="fl">1.0</span></span>
<span id="interpolation-11"><a href="#interpolation-11" aria-hidden="true" tabindex="-1"></a>        xn <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> xm</span>
<span id="interpolation-12"><a href="#interpolation-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="interpolation-13"><a href="#interpolation-13" aria-hidden="true" tabindex="-1"></a>        f1 <span class="op">=</span> <span class="va">self</span>.data[X1[:,<span class="dv">0</span>], X1[:,<span class="dv">1</span>]]</span>
<span id="interpolation-14"><a href="#interpolation-14" aria-hidden="true" tabindex="-1"></a>        f2 <span class="op">=</span> <span class="va">self</span>.data[X2[:,<span class="dv">0</span>], X1[:,<span class="dv">1</span>]]</span>
<span id="interpolation-15"><a href="#interpolation-15" aria-hidden="true" tabindex="-1"></a>        f3 <span class="op">=</span> <span class="va">self</span>.data[X1[:,<span class="dv">0</span>], X2[:,<span class="dv">1</span>]]</span>
<span id="interpolation-16"><a href="#interpolation-16" aria-hidden="true" tabindex="-1"></a>        f4 <span class="op">=</span> <span class="va">self</span>.data[X2[:,<span class="dv">0</span>], X2[:,<span class="dv">1</span>]]</span>
<span id="interpolation-17"><a href="#interpolation-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="interpolation-18"><a href="#interpolation-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>  f1 <span class="op">*</span> xn[:,<span class="dv">0</span>] <span class="op">*</span> xn[:,<span class="dv">1</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="interpolation-19"><a href="#interpolation-19" aria-hidden="true" tabindex="-1"></a>                f2 <span class="op">*</span> xm[:,<span class="dv">0</span>] <span class="op">*</span> xn[:,<span class="dv">1</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="interpolation-20"><a href="#interpolation-20" aria-hidden="true" tabindex="-1"></a>                f3 <span class="op">*</span> xn[:,<span class="dv">0</span>] <span class="op">*</span> xm[:,<span class="dv">1</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="interpolation-21"><a href="#interpolation-21" aria-hidden="true" tabindex="-1"></a>                f4 <span class="op">*</span> xm[:,<span class="dv">0</span>] <span class="op">*</span> xm[:,<span class="dv">1</span>]</span>
<span id="interpolation-22"><a href="#interpolation-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="interpolation-23"><a href="#interpolation-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gradient_2nd_order(F, i):</span>
<span id="interpolation-24"><a href="#interpolation-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>   <span class="fl">1.</span><span class="op">/</span><span class="dv">12</span> <span class="op">*</span> np.roll(F,  <span class="dv">2</span>, axis<span class="op">=</span>i) <span class="op">-</span> <span class="fl">2.</span><span class="op">/</span><span class="dv">3</span>  <span class="op">*</span> np.roll(F,  <span class="dv">1</span>, axis<span class="op">=</span>i) <span class="op">\</span></span>
<span id="interpolation-25"><a href="#interpolation-25" aria-hidden="true" tabindex="-1"></a>           <span class="op">+</span> <span class="fl">2.</span><span class="op">/</span><span class="dv">3</span>  <span class="op">*</span> np.roll(F, <span class="op">-</span><span class="dv">1</span>, axis<span class="op">=</span>i) <span class="op">-</span> <span class="fl">1.</span><span class="op">/</span><span class="dv">12</span> <span class="op">*</span> np.roll(F, <span class="op">-</span><span class="dv">2</span>, axis<span class="op">=</span>i)</span></code></pre></div>
</div>
<h2 id="leap-frog-integrator">Leap-frog integrator</h2>
<p>The Leap-frog method is a generic method for solving Hamiltonian systems. We divide the integration into a <em>kick</em> and <em>drift</em> stage. In the Leap-frog method, the kicks happen in between the drifts.</p>
<p>It is nice to write this part of the program in a formal way. We define an abstract <code>Vector</code> type, which will store the position and momentum variables.</p>
<div class="annotated-code">
<p><span><em>«integrator»=</em></span></p>
<div class="sourceCode" id="integrator"><pre class="sourceCode python"><code class="sourceCode python"><span id="integrator-1"><a href="#integrator-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VectorABC(ABC):</span>
<span id="integrator-2"><a href="#integrator-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="integrator-3"><a href="#integrator-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other: Vector) <span class="op">-&gt;</span> Vector:</span>
<span id="integrator-4"><a href="#integrator-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">NotImplementedError</span></span>
<span id="integrator-5"><a href="#integrator-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="integrator-6"><a href="#integrator-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="integrator-7"><a href="#integrator-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__rmul__</span>(<span class="va">self</span>, other: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="integrator-8"><a href="#integrator-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">NotImplementedError</span></span>
<span id="integrator-9"><a href="#integrator-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="integrator-10"><a href="#integrator-10" aria-hidden="true" tabindex="-1"></a>VectorABC.register(np.ndarray)</span>
<span id="integrator-11"><a href="#integrator-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="integrator-12"><a href="#integrator-12" aria-hidden="true" tabindex="-1"></a>Vector <span class="op">=</span> TypeVar(<span class="st">&quot;Vector&quot;</span>, bound<span class="op">=</span>VectorABC)</span></code></pre></div>
</div>
<p>Given a <code>Vector</code> type, we define the <code>State</code> to be the combination of <code>position</code>, <code>momentum</code> and <code>time</code> (due to FRW dynamics on the background, the system is time dependent).</p>
<div class="annotated-code">
<p><span><em>«integrator»+</em></span></p>
<div class="sourceCode" id="integrator"><pre class="sourceCode python"><code class="sourceCode python"><span id="integrator-1"><a href="#integrator-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="integrator-2"><a href="#integrator-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> State(Generic[Vector]):</span>
<span id="integrator-3"><a href="#integrator-3" aria-hidden="true" tabindex="-1"></a>    time : <span class="bu">float</span></span>
<span id="integrator-4"><a href="#integrator-4" aria-hidden="true" tabindex="-1"></a>    position : Vector</span>
<span id="integrator-5"><a href="#integrator-5" aria-hidden="true" tabindex="-1"></a>    momentum : Vector</span>
<span id="integrator-6"><a href="#integrator-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="integrator-7"><a href="#integrator-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>state<span class="op">-</span>methods<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We may manipulate the <code>State</code> in three ways: <code>kick</code>, <code>drift</code> or <code>wait</code>. <em>Kicking</em> the state means changing the momentum by some amound, given by the momentum equation. <em>Drifting</em> means changing the position following the position equation. <em>Waiting</em> simply sets the clock forward.</p>
<div class="annotated-code">
<p><span><em>«state-methods»=</em></span></p>
<div class="sourceCode" id="state-methods"><pre class="sourceCode python"><code class="sourceCode python"><span id="state-methods-1"><a href="#state-methods-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kick(<span class="va">self</span>, dt: <span class="bu">float</span>, h: HamiltonianSystem[Vector]) <span class="op">-&gt;</span> State[Vector]:</span>
<span id="state-methods-2"><a href="#state-methods-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.momentum <span class="op">+=</span> dt <span class="op">*</span> h.momentumEquation(<span class="va">self</span>)</span>
<span id="state-methods-3"><a href="#state-methods-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span></span>
<span id="state-methods-4"><a href="#state-methods-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="state-methods-5"><a href="#state-methods-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> drift(<span class="va">self</span>, dt: <span class="bu">float</span>, h: HamiltonianSystem[Vector]) <span class="op">-&gt;</span> State[Vector]:</span>
<span id="state-methods-6"><a href="#state-methods-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.position <span class="op">+=</span> dt <span class="op">*</span> h.positionEquation(<span class="va">self</span>)</span>
<span id="state-methods-7"><a href="#state-methods-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span></span>
<span id="state-methods-8"><a href="#state-methods-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="state-methods-9"><a href="#state-methods-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wait(<span class="va">self</span>, dt: <span class="bu">float</span>) <span class="op">-&gt;</span> State[Vector]:</span>
<span id="state-methods-10"><a href="#state-methods-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.time <span class="op">+=</span> dt</span>
<span id="state-methods-11"><a href="#state-methods-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span></span></code></pre></div>
</div>
<p>The combination of a position and momentum equation is known as a Hamiltonian system:</p>
<div class="annotated-code">
<p><span><em>«integrator»+</em></span></p>
<div class="sourceCode" id="integrator"><pre class="sourceCode python"><code class="sourceCode python"><span id="integrator-1"><a href="#integrator-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HamiltonianSystem(ABC, Generic[Vector]):</span>
<span id="integrator-2"><a href="#integrator-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="integrator-3"><a href="#integrator-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> positionEquation(<span class="va">self</span>, s: State[Vector]) <span class="op">-&gt;</span> Vector:</span>
<span id="integrator-4"><a href="#integrator-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">NotImplementedError</span></span>
<span id="integrator-5"><a href="#integrator-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="integrator-6"><a href="#integrator-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="integrator-7"><a href="#integrator-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> momentumEquation(<span class="va">self</span>, s: State[Vector]) <span class="op">-&gt;</span> Vector:</span>
<span id="integrator-8"><a href="#integrator-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">NotImplementedError</span></span></code></pre></div>
</div>
<p>A <code>Solver</code> is a function that takes a Hamiltonian system, an initial state and returns a final state. A <code>Stepper</code> translates one state to the next. The <code>HaltingCondition</code> is function of the state that determines when to stop integrating.</p>
<div class="annotated-code">
<p><span><em>«integrator»+</em></span></p>
<div class="sourceCode" id="integrator"><pre class="sourceCode python"><code class="sourceCode python"><span id="integrator-1"><a href="#integrator-1" aria-hidden="true" tabindex="-1"></a>Solver <span class="op">=</span> Callable[[HamiltonianSystem[Vector], State[Vector]], State[Vector]]</span>
<span id="integrator-2"><a href="#integrator-2" aria-hidden="true" tabindex="-1"></a>Stepper <span class="op">=</span> Callable[[State[Vector]], State[Vector]]</span>
<span id="integrator-3"><a href="#integrator-3" aria-hidden="true" tabindex="-1"></a>HaltingCondition <span class="op">=</span> Callable[[State[Vector]], <span class="bu">bool</span>]</span></code></pre></div>
</div>
<p>Now we have the tools in hand to give a very consise definition of the Leap-frog integrator, namely: <code>kick dt</code> – <code>wait dt/2</code> – <code>drift dt</code> – <code>wait dt/2</code>.</p>
<div class="annotated-code">
<p><span><em>«integrator»+</em></span></p>
<div class="sourceCode" id="integrator"><pre class="sourceCode python"><code class="sourceCode python"><span id="integrator-1"><a href="#integrator-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leap_frog(dt: <span class="bu">float</span>, h: HamiltonianSystem[Vector], s: State[Vector]) <span class="op">-&gt;</span> State[Vector]:</span>
<span id="integrator-2"><a href="#integrator-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s.kick(dt, h).wait(dt<span class="op">/</span><span class="dv">2</span>).drift(dt, h).wait(dt<span class="op">/</span><span class="dv">2</span>)</span></code></pre></div>
</div>
<p>From the integrator we can construct a <code>Stepper</code> function (<code>step = partial(leap_frog, dt, system)</code>), that we can iterate until completion. After each step, the current state is saved to a file.</p>
<div class="annotated-code">
<p><span><em>«integrator»+</em></span></p>
<div class="sourceCode" id="integrator"><pre class="sourceCode python"><code class="sourceCode python"><span id="integrator-1"><a href="#integrator-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterate_step(step: Stepper, halt: HaltingCondition, init: State[Vector]) <span class="op">-&gt;</span> State[Vector]:</span>
<span id="integrator-2"><a href="#integrator-2" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> init</span>
<span id="integrator-3"><a href="#integrator-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="kw">not</span> halt(state):</span>
<span id="integrator-4"><a href="#integrator-4" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> step(state)</span>
<span id="integrator-5"><a href="#integrator-5" aria-hidden="true" tabindex="-1"></a>        fn <span class="op">=</span> <span class="st">&#39;data/x.</span><span class="sc">{0:05d}</span><span class="st">.npy&#39;</span>.<span class="bu">format</span>(<span class="bu">int</span>(<span class="bu">round</span>(state.time<span class="op">*</span><span class="dv">1000</span>)))</span>
<span id="integrator-6"><a href="#integrator-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="bu">open</span>(fn, <span class="st">&#39;wb&#39;</span>) <span class="im">as</span> f:</span>
<span id="integrator-7"><a href="#integrator-7" aria-hidden="true" tabindex="-1"></a>            np.save(f, state.position)</span>
<span id="integrator-8"><a href="#integrator-8" aria-hidden="true" tabindex="-1"></a>            np.save(f, state.momentum)</span>
<span id="integrator-9"><a href="#integrator-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> state</span></code></pre></div>
</div>
<h2 id="poisson-solver">Poisson solver</h2>
<p>Now for the hardest bit. We need to solve the Poisson equation.</p>
<div class="annotated-code">
<p><span><em>«solver»=</em></span></p>
<div class="sourceCode" id="solver"><pre class="sourceCode python"><code class="sourceCode python"><span id="solver-1"><a href="#solver-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PoissonVlasov(HamiltonianSystem[np.ndarray]):</span>
<span id="solver-2"><a href="#solver-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, box, cosmology, particle_mass, live_plot<span class="op">=</span><span class="va">False</span>):</span>
<span id="solver-3"><a href="#solver-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.box <span class="op">=</span> box</span>
<span id="solver-4"><a href="#solver-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cosmology <span class="op">=</span> cosmology</span>
<span id="solver-5"><a href="#solver-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.particle_mass <span class="op">=</span> particle_mass</span>
<span id="solver-6"><a href="#solver-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.delta <span class="op">=</span> np.zeros(<span class="va">self</span>.box.shape, dtype<span class="op">=</span><span class="st">&#39;f8&#39;</span>)</span>
<span id="solver-7"><a href="#solver-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> live_plot:</span>
<span id="solver-8"><a href="#solver-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._g <span class="op">=</span> gp.Gnuplot(persist<span class="op">=</span><span class="va">True</span>)</span>
<span id="solver-9"><a href="#solver-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._g(<span class="st">&quot;set cbrange [0.2:50]&quot;</span>, <span class="st">&quot;set log cb&quot;</span>, <span class="st">&quot;set size square&quot;</span>,</span>
<span id="solver-10"><a href="#solver-10" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;set xrange [0:</span><span class="sc">{0}</span><span class="st">] ; set yrange [0:</span><span class="sc">{0}</span><span class="st">]&quot;</span>.<span class="bu">format</span>(box.N))</span>
<span id="solver-11"><a href="#solver-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._g(<span class="st">&quot;set term x11&quot;</span>)</span>
<span id="solver-12"><a href="#solver-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="solver-13"><a href="#solver-13" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._g <span class="op">=</span> <span class="va">False</span></span>
<span id="solver-14"><a href="#solver-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="solver-15"><a href="#solver-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>position<span class="op">-</span>equation<span class="op">&gt;&gt;</span></span>
<span id="solver-16"><a href="#solver-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>momentum<span class="op">-</span>equation<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>The position equation:</p>
<p><span id="eq:position" class="eqnos"><span class="math display">\[\partial_a x = \frac{p}{a^2 \dot{a}}\]</span><span class="eqnos-number">(17)</span></span></p>
<div class="annotated-code">
<p><span><em>«position-equation»=</em></span></p>
<div class="sourceCode" id="position-equation"><pre class="sourceCode python"><code class="sourceCode python"><span id="position-equation-1"><a href="#position-equation-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> positionEquation(<span class="va">self</span>, s: State[np.ndarray]) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="position-equation-2"><a href="#position-equation-2" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> s.time</span>
<span id="position-equation-3"><a href="#position-equation-3" aria-hidden="true" tabindex="-1"></a>    da <span class="op">=</span> <span class="va">self</span>.cosmology.da(a)</span>
<span id="position-equation-4"><a href="#position-equation-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s.momentum <span class="op">/</span> (s.time<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> da)</span></code></pre></div>
</div>
<p>The momentum equation:</p>
<p><span id="eq:momentum" class="eqnos"><span class="math display">\[\partial_a p = -\frac{1}{\dot{a}} \nabla \Phi,\]</span><span class="eqnos-number">(18)</span></span></p>
<p>where</p>
<p><span id="eq:poisson" class="eqnos"><span class="math display">\[\nabla^2 \Phi = \frac{G}{a} \delta.\]</span><span class="eqnos-number">(19)</span></span></p>
<p>We first compute <span class="math inline">\(\delta\)</span> using the cloud-in-cell mass deposition <code>md_cic()</code> function. Then we integrate twice by method of Fourier transform. To compute the accelleration we take the second-order approximation of the gradient function.</p>
<div class="annotated-code">
<p><span><em>«momentum-equation»=</em></span></p>
<div class="sourceCode" id="momentum-equation"><pre class="sourceCode python"><code class="sourceCode python"><span id="momentum-equation-1"><a href="#momentum-equation-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> momentumEquation(<span class="va">self</span>, s: State[np.ndarray]) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="momentum-equation-2"><a href="#momentum-equation-2" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> s.time</span>
<span id="momentum-equation-3"><a href="#momentum-equation-3" aria-hidden="true" tabindex="-1"></a>    da <span class="op">=</span> <span class="va">self</span>.cosmology.da(a)</span>
<span id="momentum-equation-4"><a href="#momentum-equation-4" aria-hidden="true" tabindex="-1"></a>    x_grid <span class="op">=</span> s.position <span class="op">/</span> <span class="va">self</span>.box.res</span>
<span id="momentum-equation-5"><a href="#momentum-equation-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.delta.fill(<span class="fl">0.0</span>)</span>
<span id="momentum-equation-6"><a href="#momentum-equation-6" aria-hidden="true" tabindex="-1"></a>    md_cic_2d(<span class="va">self</span>.box.shape, x_grid, <span class="va">self</span>.delta)</span>
<span id="momentum-equation-7"><a href="#momentum-equation-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.delta <span class="op">*=</span> <span class="va">self</span>.particle_mass</span>
<span id="momentum-equation-8"><a href="#momentum-equation-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.delta <span class="op">-=</span> <span class="fl">1.0</span></span>
<span id="momentum-equation-9"><a href="#momentum-equation-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="momentum-equation-10"><a href="#momentum-equation-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">abs</span>(<span class="va">self</span>.delta.mean()) <span class="op">&lt;</span> <span class="fl">1e-6</span>, <span class="st">&quot;total mass should be normalised&quot;</span></span>
<span id="momentum-equation-11"><a href="#momentum-equation-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="momentum-equation-12"><a href="#momentum-equation-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="va">self</span>._g:</span>
<span id="momentum-equation-13"><a href="#momentum-equation-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._g(gp.plot_data(gp.array(<span class="va">self</span>.delta.T<span class="op">+</span><span class="dv">1</span>, <span class="st">&quot;t&#39;&#39; w image&quot;</span>)))</span>
<span id="momentum-equation-14"><a href="#momentum-equation-14" aria-hidden="true" tabindex="-1"></a>    delta_f <span class="op">=</span> np.fft.fftn(<span class="va">self</span>.delta)</span>
<span id="momentum-equation-15"><a href="#momentum-equation-15" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> cft.Potential()(<span class="va">self</span>.box.K)</span>
<span id="momentum-equation-16"><a href="#momentum-equation-16" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> np.fft.ifftn(delta_f <span class="op">*</span> kernel).real <span class="op">*</span> <span class="va">self</span>.cosmology.G <span class="op">/</span> a</span>
<span id="momentum-equation-17"><a href="#momentum-equation-17" aria-hidden="true" tabindex="-1"></a>    acc_x <span class="op">=</span> Interp2D(gradient_2nd_order(phi, <span class="dv">0</span>))</span>
<span id="momentum-equation-18"><a href="#momentum-equation-18" aria-hidden="true" tabindex="-1"></a>    acc_y <span class="op">=</span> Interp2D(gradient_2nd_order(phi, <span class="dv">1</span>))</span>
<span id="momentum-equation-19"><a href="#momentum-equation-19" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> np.c_[acc_x(x_grid), acc_y(x_grid)] <span class="op">/</span> <span class="va">self</span>.box.res</span>
<span id="momentum-equation-20"><a href="#momentum-equation-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>acc <span class="op">/</span> da</span></code></pre></div>
</div>
<h2 id="the-zeldovich-approximation">The Zeldovich Approximation</h2>
<p>To bootstrap the simulation, we need to create a set of particles and assign velocities. This is done using the Zeldovich Approximation.</p>
<div class="annotated-code">
<p><span><em>«initialization»=</em></span></p>
<div class="sourceCode" id="initialization"><pre class="sourceCode python"><code class="sourceCode python"><span id="initialization-1"><a href="#initialization-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> a2r(B, X):</span>
<span id="initialization-2"><a href="#initialization-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X.transpose([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>]).reshape([B.N<span class="op">**</span><span class="dv">2</span>, <span class="dv">2</span>])</span>
<span id="initialization-3"><a href="#initialization-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="initialization-4"><a href="#initialization-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> r2a(B, x):</span>
<span id="initialization-5"><a href="#initialization-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x.reshape([B.N, B.N, <span class="dv">2</span>]).transpose([<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">1</span>])</span>
<span id="initialization-6"><a href="#initialization-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="initialization-7"><a href="#initialization-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Zeldovich:</span>
<span id="initialization-8"><a href="#initialization-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, B_mass: Box, B_force: Box, cosmology: Cosmology, phi: np.ndarray):</span>
<span id="initialization-9"><a href="#initialization-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bm <span class="op">=</span> B_mass</span>
<span id="initialization-10"><a href="#initialization-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bf <span class="op">=</span> B_force</span>
<span id="initialization-11"><a href="#initialization-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cosmology  <span class="op">=</span> cosmology</span>
<span id="initialization-12"><a href="#initialization-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.u <span class="op">=</span> np.array([<span class="op">-</span>gradient_2nd_order(phi, <span class="dv">0</span>),</span>
<span id="initialization-13"><a href="#initialization-13" aria-hidden="true" tabindex="-1"></a>                           <span class="op">-</span>gradient_2nd_order(phi, <span class="dv">1</span>)]) <span class="op">/</span> <span class="va">self</span>.bm.res</span>
<span id="initialization-14"><a href="#initialization-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="initialization-15"><a href="#initialization-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> state(<span class="va">self</span>, a_init: <span class="bu">float</span>) <span class="op">-&gt;</span> State[np.ndarray]:</span>
<span id="initialization-16"><a href="#initialization-16" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> a2r(<span class="va">self</span>.bm, np.indices(<span class="va">self</span>.bm.shape) <span class="op">*</span> <span class="va">self</span>.bm.res <span class="op">+</span> a_init <span class="op">*</span> <span class="va">self</span>.u)</span>
<span id="initialization-17"><a href="#initialization-17" aria-hidden="true" tabindex="-1"></a>        P <span class="op">=</span> a2r(<span class="va">self</span>.bm, a_init <span class="op">*</span> <span class="va">self</span>.u)</span>
<span id="initialization-18"><a href="#initialization-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> State(time<span class="op">=</span>a_init, position<span class="op">=</span>X, momentum<span class="op">=</span>P)</span>
<span id="initialization-19"><a href="#initialization-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="initialization-20"><a href="#initialization-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="initialization-21"><a href="#initialization-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> particle_mass(<span class="va">self</span>):</span>
<span id="initialization-22"><a href="#initialization-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="va">self</span>.bf.N <span class="op">/</span> <span class="va">self</span>.bm.N)<span class="op">**</span><span class="va">self</span>.bm.dim</span></code></pre></div>
</div>
<p>The main function</p>
<div class="annotated-code">
<p><span><em>«main»=</em></span></p>
<div class="sourceCode" id="main"><pre class="sourceCode python"><code class="sourceCode python"><span id="main-1"><a href="#main-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="main-2"><a href="#main-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> . <span class="im">import</span> cft</span>
<span id="main-3"><a href="#main-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="main-4"><a href="#main-4" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">256</span></span>
<span id="main-5"><a href="#main-5" aria-hidden="true" tabindex="-1"></a>    B_m <span class="op">=</span> Box(<span class="dv">2</span>, N, <span class="fl">50.0</span>)</span>
<span id="main-6"><a href="#main-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="main-7"><a href="#main-7" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> <span class="dv">10</span></span>
<span id="main-8"><a href="#main-8" aria-hidden="true" tabindex="-1"></a>    seed <span class="op">=</span> <span class="dv">4</span></span>
<span id="main-9"><a href="#main-9" aria-hidden="true" tabindex="-1"></a>    Power_spectrum <span class="op">=</span> cft.Power_law(<span class="op">-</span><span class="fl">0.5</span>) <span class="op">*</span> cft.Scale(B_m, <span class="fl">0.2</span>) <span class="op">*</span> cft.Cutoff(B_m)</span>
<span id="main-10"><a href="#main-10" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> cft.garfield(B_m, Power_spectrum, cft.Potential(), seed) <span class="op">*</span> A</span>
<span id="main-11"><a href="#main-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="main-12"><a href="#main-12" aria-hidden="true" tabindex="-1"></a>    force_box <span class="op">=</span> cft.Box(<span class="dv">2</span>, N<span class="op">*</span><span class="dv">2</span>, B_m.L)</span>
<span id="main-13"><a href="#main-13" aria-hidden="true" tabindex="-1"></a>    za <span class="op">=</span> Zeldovich(B_m, force_box, EdS, phi)</span>
<span id="main-14"><a href="#main-14" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> za.state(<span class="fl">0.02</span>)</span>
<span id="main-15"><a href="#main-15" aria-hidden="true" tabindex="-1"></a>    system <span class="op">=</span> PoissonVlasov(force_box, EdS, za.particle_mass, live_plot<span class="op">=</span><span class="va">True</span>)</span>
<span id="main-16"><a href="#main-16" aria-hidden="true" tabindex="-1"></a>    stepper <span class="op">=</span> partial(leap_frog, <span class="fl">0.02</span>, system)</span>
<span id="main-17"><a href="#main-17" aria-hidden="true" tabindex="-1"></a>    iterate_step(stepper, <span class="kw">lambda</span> s: s.time <span class="op">&gt;</span> <span class="fl">4.0</span>, state)</span></code></pre></div>
</div>
<h2 id="constrained-fields">Constrained fields</h2>
<p>The <code>nbody.cft</code> library computes Gaussian random fields, and you can specify constraints on these fields.</p>
<h1 id="plotting-the-phase-space-submanifold">Plotting the phase-space submanifold</h1>
<p>Instead of plotting particles, it is very nice to see the structures from phase-space. We take the original ordering of the particles at time <span class="math inline">\(a=0\)</span>, and triangulate that. Then we plot this triangulation as it folds and wrinkles when particles start to move.</p>
<p>For this visualisation we use Matplotlib.</p>
<h2 id="the-triangulation">The triangulation</h2>
<p>We split each grid volume cell into two triangles (upper and lower). The <code>box_triangles</code> function generates all triangles for a given <code>Box</code>. In this case we don’t wrap around the edges, since that would make plotting a bit awkward.</p>
<div class="annotated-code">
<p><span><em>«create-triangulation»=</em></span></p>
<div class="sourceCode" id="create-triangulation"><pre class="sourceCode python"><code class="sourceCode python"><span id="create-triangulation-1"><a href="#create-triangulation-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> box_triangles(box):</span>
<span id="create-triangulation-2"><a href="#create-triangulation-2" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> np.arange(box.size, dtype<span class="op">=</span><span class="bu">int</span>).reshape(box.shape)</span>
<span id="create-triangulation-3"><a href="#create-triangulation-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="create-triangulation-4"><a href="#create-triangulation-4" aria-hidden="true" tabindex="-1"></a>    x0 <span class="op">=</span> idx[:<span class="op">-</span><span class="dv">1</span>,:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="create-triangulation-5"><a href="#create-triangulation-5" aria-hidden="true" tabindex="-1"></a>    x1 <span class="op">=</span> idx[:<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>:]</span>
<span id="create-triangulation-6"><a href="#create-triangulation-6" aria-hidden="true" tabindex="-1"></a>    x2 <span class="op">=</span> idx[<span class="dv">1</span>:,:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="create-triangulation-7"><a href="#create-triangulation-7" aria-hidden="true" tabindex="-1"></a>    x3 <span class="op">=</span> idx[<span class="dv">1</span>:,<span class="dv">1</span>:]</span>
<span id="create-triangulation-8"><a href="#create-triangulation-8" aria-hidden="true" tabindex="-1"></a>    upper_triangles <span class="op">=</span> np.array([x0, x1, x2]).transpose([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>]).reshape([<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>])</span>
<span id="create-triangulation-9"><a href="#create-triangulation-9" aria-hidden="true" tabindex="-1"></a>    lower_triangles <span class="op">=</span> np.array([x3, x2, x1]).transpose([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>]).reshape([<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>])</span>
<span id="create-triangulation-10"><a href="#create-triangulation-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.r_[upper_triangles, lower_triangles]</span></code></pre></div>
</div>
<h2 id="density">Density</h2>
<p>To compute the density on the triangulation we take the inverse of each triangle’s area. The area of a triangle can be computed using the formula,</p>
<p><span id="eq:triangle-area" class="eqnos"><span class="math display">\[A = \frac{1}{2}(x_1 y_2 + x_2 y_3 + x_3 y_0 - x_2 y_1 - x_3 y_2 - x_0 y_3).\]</span><span class="eqnos-number">(20)</span></span></p>
<div class="annotated-code">
<p><span><em>«triangle-area»=</em></span></p>
<div class="sourceCode" id="triangle-area"><pre class="sourceCode python"><code class="sourceCode python"><span id="triangle-area-1"><a href="#triangle-area-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> triangle_area(x, y, t):</span>
<span id="triangle-area-2"><a href="#triangle-area-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x[t[:,<span class="dv">0</span>]] <span class="op">*</span> y[t[:,<span class="dv">1</span>]] <span class="op">+</span> x[t[:,<span class="dv">1</span>]] <span class="op">*</span> y[t[:,<span class="dv">2</span>]] <span class="op">+</span> x[t[:,<span class="dv">2</span>]] <span class="op">*</span> y[t[:,<span class="dv">0</span>]] <span class="op">\</span></span>
<span id="triangle-area-3"><a href="#triangle-area-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">-</span> x[t[:,<span class="dv">1</span>]] <span class="op">*</span> y[t[:,<span class="dv">0</span>]] <span class="op">-</span> x[t[:,<span class="dv">2</span>]] <span class="op">*</span> y[t[:,<span class="dv">1</span>]] <span class="op">-</span> x[t[:,<span class="dv">0</span>]] <span class="op">*</span> y[t[:,<span class="dv">2</span>]]) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
</div>
<h2 id="plotting">Plotting</h2>
<p>The <code>plot_for_time</code> function reads the data from the previously saved <code>.npy</code> file and plots the phase-space triangulation. Note that we need to sort the triangles on their density, so that the most dense triangles are plotted last.</p>
<div class="annotated-code">
<p><span><em>«phase-space-plot»=</em></span></p>
<div class="sourceCode" id="phase-space-plot"><pre class="sourceCode python"><code class="sourceCode python"><span id="phase-space-plot-1"><a href="#phase-space-plot-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_for_time(box, triangles, time, bbox<span class="op">=</span>[(<span class="dv">5</span>,<span class="dv">45</span>), (<span class="dv">5</span>,<span class="dv">45</span>)], fig<span class="op">=</span><span class="va">None</span>, ax<span class="op">=</span><span class="va">None</span>):</span>
<span id="phase-space-plot-2"><a href="#phase-space-plot-2" aria-hidden="true" tabindex="-1"></a>    fn <span class="op">=</span> <span class="st">&#39;data/x.</span><span class="sc">{0:05d}</span><span class="st">.npy&#39;</span>.<span class="bu">format</span>(<span class="bu">int</span>(<span class="bu">round</span>(time<span class="op">*</span><span class="dv">1000</span>)))</span>
<span id="phase-space-plot-3"><a href="#phase-space-plot-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(fn, <span class="st">&quot;rb&quot;</span>) <span class="im">as</span> f:</span>
<span id="phase-space-plot-4"><a href="#phase-space-plot-4" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.load(f)</span>
<span id="phase-space-plot-5"><a href="#phase-space-plot-5" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> np.load(f)</span>
<span id="phase-space-plot-6"><a href="#phase-space-plot-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="phase-space-plot-7"><a href="#phase-space-plot-7" aria-hidden="true" tabindex="-1"></a>    area <span class="op">=</span> <span class="bu">abs</span>(triangle_area(x[:,<span class="dv">0</span>], x[:,<span class="dv">1</span>], triangles)) <span class="op">/</span> box.res<span class="op">**</span><span class="dv">2</span></span>
<span id="phase-space-plot-8"><a href="#phase-space-plot-8" aria-hidden="true" tabindex="-1"></a>    sorting <span class="op">=</span> np.argsort(area)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="phase-space-plot-9"><a href="#phase-space-plot-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="phase-space-plot-10"><a href="#phase-space-plot-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ax <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="phase-space-plot-11"><a href="#phase-space-plot-11" aria-hidden="true" tabindex="-1"></a>        fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))</span>
<span id="phase-space-plot-12"><a href="#phase-space-plot-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="phase-space-plot-13"><a href="#phase-space-plot-13" aria-hidden="true" tabindex="-1"></a>    ax.tripcolor(x[:,<span class="dv">0</span>], x[:,<span class="dv">1</span>], triangles[sorting], np.log(<span class="fl">1.</span><span class="op">/</span>area[sorting]),</span>
<span id="phase-space-plot-14"><a href="#phase-space-plot-14" aria-hidden="true" tabindex="-1"></a>                  alpha<span class="op">=</span><span class="fl">0.3</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>, cmap<span class="op">=</span><span class="st">&#39;YlGnBu&#39;</span>)</span>
<span id="phase-space-plot-15"><a href="#phase-space-plot-15" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="op">*</span>bbox[<span class="dv">0</span>])</span>
<span id="phase-space-plot-16"><a href="#phase-space-plot-16" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">*</span>bbox[<span class="dv">1</span>])</span>
<span id="phase-space-plot-17"><a href="#phase-space-plot-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig, ax</span></code></pre></div>
</div>
<h2 id="main-script">Main script</h2>
<div class="annotated-code">
<p><span><em>«nbody/phase_plot.py»=</em></span></p>
<div class="sourceCode" id="cb3" data-file="nbody/phase_plot.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> rcParams</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nbody.cft <span class="im">import</span> Box</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>rcParams[<span class="st">&quot;font.family&quot;</span>] <span class="op">=</span> <span class="st">&quot;serif&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>create<span class="op">-</span>triangulation<span class="op">&gt;&gt;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>triangle<span class="op">-</span>area<span class="op">&gt;&gt;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>phase<span class="op">-</span>space<span class="op">-</span>plot<span class="op">&gt;&gt;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    box <span class="op">=</span> Box(<span class="dv">2</span>, <span class="dv">256</span>, <span class="fl">50.0</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    triangles <span class="op">=</span> box_triangles(box)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    fig, axs <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, t <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>]):</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        plot_for_time(box, triangles, t, fig<span class="op">=</span>fig, ax<span class="op">=</span>axs[<span class="dv">0</span>,i])</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        axs[<span class="dv">0</span>,i].set_title(<span class="ss">f&quot;a = </span><span class="sc">{t}</span><span class="ss">&quot;</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, t <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>]):</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        plot_for_time(box, triangles, t, bbox<span class="op">=</span>[(<span class="dv">15</span>,<span class="dv">30</span>), (<span class="dv">5</span>, <span class="dv">20</span>)], fig<span class="op">=</span>fig, ax<span class="op">=</span>axs[<span class="dv">1</span>,i])</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    fig.tight_layout()</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    fig.savefig(<span class="st">&#39;docs/figures/x.collage.png&#39;</span>, dpi<span class="op">=</span><span class="dv">150</span>)</span></code></pre></div>
</div>
<h1 id="introducing-constrained-fields">Introducing Constrained Fields</h1>
<p>Constraint Gaussian Random Fields are an important tool to manipulate initial conditions, while making sure that resulting fields still follow the underlying correlation function, keeping an eye on the probability of such conditions arising within a certain volume. The algorithm used here was delevoped by <span class="citation" data-cites="Hoffman1991"><a href="#ref-Hoffman1991" role="doc-biblioref">Hoffman and Ribak</a> (<a href="#ref-Hoffman1991" role="doc-biblioref">1991</a>)</span>; a more complete overview and applications are found in <span class="citation" data-cites="Weygaert1996"><a href="#ref-Weygaert1996" role="doc-biblioref">Van de Weygaert and Bertschinger</a> (<a href="#ref-Weygaert1996" role="doc-biblioref">1996</a>)</span>.</p>
<p>What do we know about GRFs? We have a one-point function of</p>
<p><span class="math display">\[\mathcal{P}(f_1) = \frac{1}{\sqrt{\tau v}} \exp \left[-\frac{f_1}{2v}\right]\]</span></p>
<p>and an <span class="math inline">\(N\)</span>-point function of</p>
<p><span class="math display">\[\mathcal{P}(f) = \frac{1}{\sqrt{\tau^N \det M}} \exp\left[-\frac{1}{2}f^{\dagger}M^{-1}f\right],\]</span></p>
<p>where <span class="math inline">\(f\)</span> is now an <span class="math inline">\(N\)</span>-vector of values, and <span class="math inline">\(M\)</span> the <span class="math inline">\((N \times N)\)</span>-covariance-matrix,</p>
<p><span class="math display">\[M_{ij} = \langle f_i^*f_j\rangle.\]</span></p>
<p>In the case of Gaussian random fields, all the <span class="math inline">\(N\)</span>-point functions can be described in terms of the two-point function, and we can write the covariance matrix as</p>
<p><span class="math display">\[M_{(2)} = \begin{pmatrix} v &amp; \xi \\ \xi &amp; v \end{pmatrix},\]</span></p>
<p>where <span class="math inline">\(\xi\)</span> is the <em>two-point correlation function</em>. In the paper by <span class="citation" data-cites="Weygaert1996">(<a href="#ref-Weygaert1996" role="doc-biblioref">Van de Weygaert and Bertschinger 1996</a>)</span>, the <span class="math inline">\(N\)</span>-point function is written in a functional form. We will be focussing on the computation of CGRFs, we will keep the matrix the notation for finite <span class="math inline">\(N\)</span>. Computing the expectation value of a quantity <span class="math inline">\(A(f)\)</span>,</p>
<p><span class="math display">\[\langle A\rangle = \int A(f) \mathcal{P}(f) {\rm d}^N f,\]</span> assuming <span class="math inline">\(\mathcal{P}(f)\)</span> is properly normalised.</p>
<p>To show the difference between an uncorrelated and correlated random field, I have created three instances of a GRF below with <em>power spectrum</em> of <span class="math inline">\(P(k) = k^{n}\)</span>, where <span class="math inline">\(n = 0, -1, -2\)</span>. The value in each cell is an element in the vector <span class="math inline">\(f\)</span>.</p>
<h2 id="constraints">Constraints</h2>
<p>We will influence the generating of a random field by imposing constraints. For example, we might want a density peak in the center of our box, then we can encode this wish in a series of constraints: scaled with a certain gaussian filter the gradient is zero, and the density has some positive value, while the second derivatives are all negative. The field is then subject to a set of <span class="math inline">\(M\)</span> constraints such that,</p>
<p><span class="math display">\[\Gamma = \left\{ C_i(f) = g_i ; i = 1, \dots, M \right\}.\]</span></p>
<p>For practical purposes we have to make sure that each costraint function <span class="math inline">\(C_i\)</span> is linear in the sense that it can be expressed in terms of a linear combination of all elements in <span class="math inline">\(f,\)</span></p>
<p><span class="math display">\[C_i(f) = \langle\mathcal{C}_i, f\rangle,\]</span></p>
<p>or if you will, there is a matrix <span class="math inline">\(N \times M\)</span> matrix <span class="math inline">\(C\)</span> that transforms <span class="math inline">\(f\)</span>, to the set of constraint values <span class="math inline">\(g\)</span>.</p>
<p>In particular the case where the constraint can be expressed as a convolution is common</p>
<p><span class="math display">\[C_i(f, x) = \frac{1}{N}\sum_i g(x - y_i) f(y_i).\]</span></p>
<p>The problem is how to sample the possible constraint realisations properly,</p>
<p><span class="math display">\[\mathcal{P}\big(f|\Gamma\big) = \frac{\mathcal{P}\big(f \cap \Gamma\big)}{\mathcal{P}
\big(\Gamma\big)} = \frac{\mathcal{P}\big(f\big)}{\mathcal{P}\big(\Gamma\big)}.\]</span></p>
<p>Since the coefficients <span class="math inline">\(c_i\)</span> are linear combinations of Gaussian variables, they are themselves distributed as a multivariate Gaussian with the covariance matrix <span class="math inline">\(Q_{ij} = \langle g_i^* g_j\rangle = CMC^{\dagger},\)</span> (how do we show this last equality? <span class="math inline">\((AB)^{-1} = B^{-1}A^{-1}\)</span> then substitute in <span class="math inline">\(N\)</span>-point distribution)</p>
<p><span class="math display">\[\mathcal{P}\big(\Gamma\big) = \frac{1}{\sqrt{\tau^M \det Q}} \exp\left[-\frac{1}{2}g^{\dagger}Q^{-1}g\right].\]</span></p>
<p><span class="math display">\[\mathcal{P}\big(f|\Gamma\big) = \sqrt{\frac{\tau^M \det Q}{\tau^N \det M}} \exp\left[-\frac{1}{2}\left(f^{\dagger}M^{-1}f - g^{\dagger}Q^{-1}g\right)\right]\]</span></p>
<p>The term in the exponential can be written in the form <span class="math inline">\(1/2F^{\dagger} M^{-1} F\)</span>, where <span class="math inline">\(F = f - \bar{f}\)</span>. Defining <span class="math inline">\(\bar{f}\)</span>, the mean field under the constraints as</p>
<p><span class="math display">\[\bar{f} := MC^{\dagger}Q^{-1}g = \big\langle f | \Gamma \big\rangle.\]</span></p>
<p>The combination <span class="math inline">\(MC^{\dagger}\)</span> equals the cross-correlation between the random field and the set of constraints <span class="math inline">\(\langle f C_i(f)\rangle\)</span>. If we were to substitute <span class="math inline">\(C^{-\dagger}M^{-1}C^{-1}\)</span> into this definition, we would get the expression <span class="math inline">\(C^{-1} g\)</span>, but <span class="math inline">\(C\)</span> is in general not invertible. According to <em>Bertschinger (1987)</em> (B87), <span class="math inline">\(f = \bar{f}\)</span> is a stationary point of the action: <span class="math inline">\(\delta S/\delta f = 0\)</span> for <span class="math inline">\(f = \bar{f}\)</span>. Where the <em>action</em> <span class="math inline">\(S\)</span> is the term in the exponential of the distribution function. This computation is apparently explained in <em>Bardeen et al. (1986)</em> (BBKS).</p>
<p>Moving back to WB96 and its appendix C, we now see that the constrained field is the sum of an average part <span class="math inline">\(\bar{f}\)</span> and a residual part <span class="math inline">\(F\)</span>. The insight needed is that an unconstrained field <span class="math inline">\(\tilde{f}\)</span> will have non-zero constraint coefficients <span class="math inline">\(\tilde{g} = C\tilde{f}\)</span>. Since everything is linear, all we need to do is add to the unconstrained field an average field with coefficients <span class="math inline">\(g - \tilde{g}\)</span>. Suppose there are two sets of constraints <span class="math inline">\(\Gamma_1\)</span> and <span class="math inline">\(\Gamma_2\)</span>, and we have a realisation <span class="math inline">\(f_1\)</span> with constraint coefficients <span class="math inline">\(g_1 = C f_1\)</span>, then we can transform this realisation into <span class="math inline">\(f_2\)</span> with <span class="math inline">\(g_2 = C f_2\)</span> as follows</p>
<p><span class="math display">\[f_2 = f_1 - \bar{f}_1 + \bar{f}_2.\]</span></p>
<p>This implies that there is a bijection between the realisations of two sets of constraints. In other words, for each realisation <span class="math inline">\(f\)</span>, drawn from the distribution with constraints <span class="math inline">\(\Gamma_1\)</span>, there is one with equal probability from <span class="math inline">\(\Gamma_2\)</span>, or</p>
<p><span class="math display">\[\mathcal{P}\big(f_1 | \Gamma_1\big) = \mathcal{P}\big(f_2 | \Gamma_2\big).\]</span></p>
<p>This also means that the residual field <span class="math inline">\(F\)</span> is independent of the chosen constraint coefficients.</p>
<p>Computing the average field seems like a lot of work, since there is the matrix <span class="math inline">\(M\)</span> in the expression. However, if we do all our work in Fourier space, the different modes <span class="math inline">\(\hat{f}(k)\)</span> are independent, and <span class="math inline">\(M\)</span> is diagonal. Again, because the Fourier transformation is linear, we retain all nice properties that we just derived.</p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-Hoffman1991" class="csl-entry" role="doc-biblioentry">
Hoffman, Yehuda, and Erez Ribak. 1991. <span>“Constrained Realizations of Gaussian Fields-a Simple Algorithm.”</span> <em>The Astrophysical Journal</em> 380: L5–8.
</div>
<div id="ref-Ryden2017" class="csl-entry" role="doc-biblioentry">
Ryden, Barbara. 2017. <em>Introduction to Cosmology</em>. Cambridge University Press.
</div>
<div id="ref-Weygaert1996" class="csl-entry" role="doc-biblioentry">
Van de Weygaert, Rien, and Edmund Bertschinger. 1996. <span>“Peak and Gravity Constraints in Gaussian Primordial Density Fields: An Application of the Hoffman-Ribak Method.”</span> <em>Monthly Notices of the Royal Astronomical Society</em> 281 (1): 84–118.
</div>
</div>
</div></main>



<!-- Bootstrap 4.5.0 -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

<!-- Mathjax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
